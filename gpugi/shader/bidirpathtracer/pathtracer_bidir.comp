#version 440

#include "../stdheader.glsl"
#include "lightcache.glsl"

layout(binding = 0, rgba32f) restrict uniform image2D OutputTexture; // attention! No coherent flag set!

#define MIN_CONNECTION_DISTSQ 0.0001

#define LOCAL_SIZE 8
layout (local_size_x = LOCAL_SIZE, local_size_y = LOCAL_SIZE, local_size_z = 1) in;
void main()
{
	ivec2 gridPosition = ivec2(gl_GlobalInvocationID.xy);
	uint randomSeed = InitRandomSeed(FrameSeed, gridPosition.x + gridPosition.y * BackbufferSize.x);
	vec2 screenCoord = (Random2(randomSeed) + gridPosition) / BackbufferSize * 2.0 - 1.0; // Random2 gives [0,1[. Adding [0, BackbufferSize[ should result in [0, BackbufferSize]

	Ray ray;
	ray.Origin = CameraPosition;
	ray.Direction = normalize(screenCoord.x*CameraU + screenCoord.y*CameraV + CameraW);

	vec3 color = vec3(0.0);
	vec3 pathThroughput = vec3(1.0);
	bool didNextEventEstimation = false;

	uint actualNumLightCacheEntries = min(NumLightCacheEntries, LightCacheCapacity);

	// recursive MIS construction.
	float pathProbability = 1.0;
	float anyPathProbabilitySum = 0.0;

	for(int i=0; i<MAX_PATHLENGTH; ++i)
	{
		// Trace ray.
		Triangle triangle;
		vec3 barycentricCoord;
		float rayHit = RAY_MAX;
		TraceRay(ray, rayHit, barycentricCoord, triangle);
		if(rayHit == RAY_MAX)
			break;

		ray.Origin = ray.Origin + rayHit * ray.Direction;	// Go to surface with recursive ray (no epsilon yet!)

		// Compute hit normal and texture coordinate.
		vec3 hitNormal; vec2 hitTexcoord;
		GetTriangleHitInfo(triangle, barycentricCoord, hitNormal, hitTexcoord);
		// Get Material infos.
		MaterialData materialData = SampleMaterialData(triangle.w, hitTexcoord);
		
		// See pathtracer.comp
		if( !didNextEventEstimation )
			color += pathThroughput * materialData.Emissivity;

		// Connect to random light samples ("Next Event Estimation")
		didNextEventEstimation = materialData.Reflectiveness.w < 500.0;
		if( didNextEventEstimation )
		{
			Ray lightRay;
			for(int lightSample=0; lightSample<AverageLightPathLength; ++lightSample)
			{
				uint lightCacheSampleIndex = RandomUInt(randomSeed) % actualNumLightCacheEntries;
			
				lightRay.Direction = LightCacheEntries[lightCacheSampleIndex].Position - ray.Origin;
				float lightDistSq = dot(lightRay.Direction, lightRay.Direction);

				if(lightDistSq < MIN_CONNECTION_DISTSQ)
					continue;

				float lightDist = sqrt(lightDistSq);
				lightRay.Direction /= lightDist + DIVISOR_EPSILON;
				lightRay.Origin = RAY_HIT_EPSILON * lightRay.Direction + ray.Origin;

				if(!TraceRayAnyHit(lightRay, lightDist - RAY_HIT_EPSILON)) // Important to subtract epsilon, since light sample may be slightly behind the surface
				{
				#ifdef SHOW_SPECIFIC_PATHLENGTH
					int pathLength = LightCacheEntries[lightCacheSampleIndex].PathLength + i + 1;
					if(pathLength != SHOW_SPECIFIC_PATHLENGTH)
						continue;
				#endif

					int lightSampleMaterialIndex = LightCacheEntries[lightCacheSampleIndex].MaterialIndex;
					vec3 lightSampleFlux = LightCacheEntries[lightCacheSampleIndex].Flux;
					vec3 lightSampleHitNormal = vec3(0.0);
					float connectionLightPathToEyePath;
					float cosLight = 0.0;
					vec3 lightSampleIntensity;

					if(LightCacheEntries[lightCacheSampleIndex].Normal1 <= 1.0)
					{
						lightSampleHitNormal = UnpackNormal(LightCacheEntries[lightCacheSampleIndex].Normal0, LightCacheEntries[lightCacheSampleIndex].Normal1);
						cosLight = saturate(-dot(lightRay.Direction, lightSampleHitNormal));
					}

					// Triangle material
					if(lightSampleMaterialIndex != -1)
					{
						MaterialData lightSampleMaterialData = SampleMaterialData(lightSampleMaterialIndex, LightCacheEntries[lightCacheSampleIndex].Texcoord);

						float pdf;
						vec3 lightBSDF = AdjointBSDF(LightCacheEntries[lightCacheSampleIndex].IncidentDirection, -lightRay.Direction,
												lightSampleMaterialData, lightSampleHitNormal, pdf);

						lightSampleIntensity = lightSampleFlux * lightBSDF * cosLight;

						#ifdef RUSSIAN_ROULETTE
							// path continuation probability (russian roulette): saturate(bsdf * dot(N, outDir) / pdf)
							// connection probability: continuation * pdf = bsdf * dot(N, outDir)
							connectionLightPathToEyePath = MISHeuristic(saturate(GetLuminance(lightBSDF) * cosLight / (pdf + DIVISOR_EPSILON)) * pdf);
						#else
							connectionLightPathToEyePath = MISHeuristic(pdf);
						#endif
					}
					// Connect to a light source.
					else
					{
						connectionLightPathToEyePath = MISHeuristic(1.0); // Only possible via THIS next event estimation -> Fixed propability of 1.
						if(LightCacheEntries[lightCacheSampleIndex].Normal1 <= 1.0)
							lightSampleIntensity = lightSampleFlux * (cosLight * PI_2);// hemispherical light source
						else
							lightSampleIntensity = lightSampleFlux * (PI_2);// omnidirectional light source
					}

					float cosCamera = saturate(dot(lightRay.Direction, hitNormal));

					float pdf;
					vec3 bsdf = BSDF(ray.Direction, lightRay.Direction, materialData, hitNormal, pdf); // Note that this is also 1/samplingProbability!

				#ifdef RUSSIAN_ROULETTE
					// path continuation probability (russian roulette): saturate(bsdf * dot(N, outDir) / pdf)
					// connection probability: continuation * pdf = bsdf * dot(N, outDir)
					float connectionEyePathToLightPath = MISHeuristic(saturate(GetLuminance(bsdf) * cosCamera / (pdf + DIVISOR_EPSILON)) * pdf);
				#else
					float connectionEyePathToLightPath = MISHeuristic(pdf);
				#endif

					float light_pathProbability = LightCacheEntries[lightCacheSampleIndex].PathProbability;
					float light_anyPathProbabilitySum = LightCacheEntries[lightCacheSampleIndex].AnyPathProbabilitySum;

					float connectedPathPropability = light_pathProbability * pathProbability;
					float mis = connectedPathPropability / 
								(light_pathProbability * connectionEyePathToLightPath * anyPathProbabilitySum + 
								 pathProbability * connectionLightPathToEyePath * light_anyPathProbabilitySum + connectedPathPropability + DIVISOR_EPSILON);

					vec3 irradiance = (mis * cosCamera / lightDistSq) * lightSampleIntensity;
					color += irradiance * pathThroughput * bsdf; 
				}
			}
		}

		float samplePDF;
		vec3 throughput = vec3(1.0);
		ray.Direction = SampleBSDF(ray.Direction, materialData, randomSeed, hitNormal, throughput, samplePDF);
		ray.Origin += ray.Direction * RAY_HIT_EPSILON;
		pathThroughput *= throughput;
	#ifdef RUSSIAN_ROULETTE
		float continuationPropability = saturate(GetLuminance(throughput));
		if(Random(randomSeed) >= continuationPropability) // if continuationPropability is zero, path should be stoped -> >=
			break;
		pathThroughput /= continuationPropability; // Only change in spectrum, no energy loss.
		samplePDF *= continuationPropability;
	#endif

		// The probability to sample a vertex is the pdf times 1-terminationProbability
		samplePDF = MISHeuristic(samplePDF);
		anyPathProbabilitySum = anyPathProbabilitySum * samplePDF + pathProbability;
		pathProbability *= samplePDF;
	}

	float lightSampleWeight = float(actualNumLightCacheEntries) / (AverageLightPathLength + 1);
	color *= lightSampleWeight;

	vec4 final = vec4(color, 1.0);
	final += imageLoad(OutputTexture, gridPosition);
	imageStore(OutputTexture, gridPosition, final);
}