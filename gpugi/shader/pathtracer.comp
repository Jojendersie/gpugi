#version 450

#include "scenedata.glsl"
#include "intersectiontests.glsl"
#include "random.glsl"
#include "helper.glsl"
#include "globaluniforms.glsl"
#include "materials.glsl"

#define NUM_LIGHT_SAMPLES 1

#define MAX_NUM_BOUNCES 16
#define RAY_HIT_EPSILON 0.001
#define RAY_MAX 3.40282347e+38
#define RUSSIAN_ROULETTE

layout(binding = 0, rgba32f) restrict uniform image2D OutputTexture; // attention! No coherent flag set!

// Debug variables for traceray.
/*#define TRACERAY_DEBUG_VARS
uint numBoxesVisited = 0;
uint numTrianglesVisited = 0;*/

// Two versions of trace ray.
#include "pathtracer_traceray.glsl"
#define ANY_HIT
#include "pathtracer_traceray.glsl"
#undef ANY_HIT

#define LOCAL_SIZE 8
layout (local_size_x = LOCAL_SIZE, local_size_y = LOCAL_SIZE, local_size_z = 1) in;
void main()
{
	ivec2 gridPosition = ivec2(gl_GlobalInvocationID.xy);
	uint randomSeed = InitRandomSeed(FrameSeed, gridPosition.x + gridPosition.y * BackbufferSize.x);
	vec2 screenCoord = (Random2(randomSeed) + gridPosition) / BackbufferSize * 2.0 - 1.0; // Random2 gives [0,1[. Adding [0, BackbufferSize[ should result in [0, BackbufferSize]

	Ray ray;
	ray.Origin = CameraPosition;
	ray.Direction = normalize(screenCoord.x*CameraU + screenCoord.y*CameraV + CameraW);

	vec3 color = vec3(0.0);
	vec3 rayColor = vec3(1.0);

	const float lightSampleWeight = float(NumLightSamples) / NUM_LIGHT_SAMPLES; // This could be a uniform!

	for(int i=0; i<MAX_NUM_BOUNCES; ++i)
	{
		// Trace ray.
		Triangle triangle;
		vec3 barycentricCoord;
		float rayHit = RAY_MAX;
		TraceRay(ray, rayHit, barycentricCoord, triangle);
		if(rayHit == RAY_MAX)
			break;

		// Compute hit normal and texture coordinate.
		vec4 vdata0 = texelFetch(VertexInfoBuffer, triangle.x);
		vec4 vdata1 = texelFetch(VertexInfoBuffer, triangle.y);
		vec4 vdata2 = texelFetch(VertexInfoBuffer, triangle.z);
		vec3 hitNormal = normalize(UnpackNormal(vdata0.xy) * barycentricCoord.x + 
						 		   UnpackNormal(vdata1.xy) * barycentricCoord.y +
								   UnpackNormal(vdata2.xy) * barycentricCoord.z);

		vec2 hitTexcoord = vdata0.zw * barycentricCoord.x + 
						   vdata1.zw * barycentricCoord.y +
						   vdata2.zw * barycentricCoord.z;
		
		vec4 reflectiveness = textureLod(sampler2D(Materials[triangle.w].reflectivenessTexHandle), hitTexcoord, 0.0);
		vec3 opacity = textureLod(sampler2D(Materials[triangle.w].opacityTexHandle), hitTexcoord, 0.0).xyz;
		vec3 diffuse = textureLod(sampler2D(Materials[triangle.w].diffuseTexHandle), hitTexcoord, 0.0).xyz;

		// Connect to random light samples ("Next Event Estimation")
		Ray lightRay;
		//lightRay.Origin = ray.Origin + (rayHit-RAY_HIT_EPSILON) * ray.Direction;
		ray.Origin = ray.Origin + rayHit * ray.Direction;	// Go to surface with recursive ray
		for(int lightSample=0; lightSample<NUM_LIGHT_SAMPLES; ++lightSample)
		{
			int sampleIndex = int(RandomUInt(randomSeed) % NumLightSamples);
			vec4 lightSamplePosNorm = texelFetch(LightSampleBuffer, sampleIndex * 2);

			lightRay.Direction = lightSamplePosNorm.xyz - ray.Origin;
			float lightDistSq = dot(lightRay.Direction, lightRay.Direction);
			float lightDist = sqrt(lightDistSq);
			lightRay.Direction /= lightDist;
			rayHit = lightDist;
			lightRay.Origin = ray.Origin + RAY_HIT_EPSILON * lightRay.Direction;

			if(!TraceRayAnyHit(lightRay, rayHit))
			{
				vec4 lightSampleLumPrev = texelFetch(LightSampleBuffer, sampleIndex * 2 + 1);
				vec3 brdf = BRDF(ray.Direction, lightRay.Direction, triangle.w, reflectiveness, opacity, diffuse, hitNormal);
				vec3 illuminance = (lightSampleWeight *		// Divide by p for Montecarlo
					saturate(dot(lightRay.Direction, hitNormal)) / lightDistSq) * lightSampleLumPrev.xyz;
				color += illuminance * rayColor * brdf; 
			}
		}

		// Bounce ray if not the last iteration.
		//if(i+1 < MAX_NUM_BOUNCES) // Not using is faster on GM107 on 10.11.
		{
			vec3 weight;
			ray.Direction = SampleBRDF(ray.Direction, triangle.w, reflectiveness, opacity, diffuse, randomSeed, hitNormal, weight);
			ray.Origin = ray.Origin + RAY_HIT_EPSILON * sign(dot(ray.Direction, hitNormal)) * hitNormal;	// Go epsilon in sampling direction (refraction/reflection different)
#ifdef RUSSIAN_ROULETTE
			float hitLuminance = GetLuminance(weight);
			if(Random(randomSeed) > hitLuminance)
				break;
			rayColor *= weight / hitLuminance; // Only change in spectrum, no energy loss.
#else
			rayColor *= weight; // Absorption, not via Russion Roulette, but by color multiplication.
#endif
		}
	}

	vec4 final = vec4(color, 1.0);
	//vec4 final = vec4(vec3(float(numBoxesVisited) * 0.001), 1.0);
	final += imageLoad(OutputTexture, gridPosition);
	imageStore(OutputTexture, gridPosition, final);
	//FragColor = vec4(color, 1.0); //vec4(vec3(float(numBoxesVisited) * 0.001), 1.0);
}