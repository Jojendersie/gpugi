#version 440

#define SAMPLEBSDF_OUTPUT_PDF

#include "stdheader.glsl"
#include "lightcache.glsl"

layout(binding = 0, rgba32f) restrict uniform image2D OutputTexture; // attention! No coherent flag set!

#define MAX_PATHLENGTH 8

#define LOCAL_SIZE 8
layout (local_size_x = LOCAL_SIZE, local_size_y = LOCAL_SIZE, local_size_z = 1) in;
void main()
{
	ivec2 gridPosition = ivec2(gl_GlobalInvocationID.xy);
	uint randomSeed = InitRandomSeed(FrameSeed, gridPosition.x + gridPosition.y * BackbufferSize.x);
	vec2 screenCoord = (Random2(randomSeed) + gridPosition) / BackbufferSize * 2.0 - 1.0; // Random2 gives [0,1[. Adding [0, BackbufferSize[ should result in [0, BackbufferSize]

	Ray ray;
	ray.Origin = CameraPosition;
	ray.Direction = normalize(screenCoord.x*CameraU + screenCoord.y*CameraV + CameraW);

	vec3 color = vec3(0.0);
	vec3 pathThroughput = vec3(1.0);

	uint actualNumLightCacheEntries = min(NumLightCacheEntries, LightCacheCapacity);
	float lightSampleWeight = float(actualNumLightCacheEntries) / NUM_SAMPLING_TECHNIQUES;

	// recursive MIS construction.
	float pathProbability = 1.0;
	float anyPathProbabilitySum = 0.0;

	for(int i=0; i<MAX_PATHLENGTH; ++i)
	{
		// Trace ray.
		Triangle triangle;
		vec3 barycentricCoord;
		float rayHit = RAY_MAX;
		TraceRay(ray, rayHit, barycentricCoord, triangle);
		if(rayHit == RAY_MAX)
			break;

		// Compute hit normal and texture coordinate.
		vec3 hitNormal; vec2 hitTexcoord;
		GetTriangleHitInfo(triangle, barycentricCoord, hitNormal, hitTexcoord);
		// Get Material infos.
		MaterialTextureData materialTexData = SampleMaterialData(triangle.w, hitTexcoord);

		// Connect to random light samples ("Next Event Estimation")
		Ray lightRay;
		ray.Origin = ray.Origin + rayHit * ray.Direction;	// Go to surface with recursive ray (no epsilon yet!)
		for(int lightSample=0; lightSample<NUM_CAMPATH_LIGHTSAMPLE_CONNECTIONS; ++lightSample)
		{
			uint lightCacheSampleIndex = RandomUInt(randomSeed) % actualNumLightCacheEntries;
		
			lightRay.Direction = LightCacheEntries[lightCacheSampleIndex].Position - ray.Origin;
			float lightDistSq = dot(lightRay.Direction, lightRay.Direction);

			//if(lightDistSq < RAY_HIT_EPSILON * 10.0)
			//	continue;

			float lightDist = sqrt(lightDistSq);
			lightRay.Direction /= lightDist + DIVISOR_EPSILON;
			lightRay.Origin = RAY_HIT_EPSILON * lightRay.Direction + ray.Origin;

			if(!TraceRayAnyHit(lightRay, lightDist - RAY_HIT_EPSILON)) // Important to subtract epsilon, since light sample may be slightly behind the surface
			{
				int lightSampleMaterialIndex = LightCacheEntries[lightCacheSampleIndex].MaterialIndex;
				vec3 lightSampleIntensity = LightCacheEntries[lightCacheSampleIndex].Intensity;
				float connectionLightPathToEyePath = 1.0;

				// Triangle material
				if(lightSampleMaterialIndex != -1)
				{
					int lightSampleMaterialIndex = LightCacheEntries[lightCacheSampleIndex].MaterialIndex;
					MaterialTextureData lightSampleMaterialTexData = SampleMaterialData(lightSampleMaterialIndex, LightCacheEntries[lightCacheSampleIndex].Texcoord);

					vec3 lightSampleHitNormal = UnpackNormal(LightCacheEntries[lightCacheSampleIndex].Normal0, LightCacheEntries[lightCacheSampleIndex].Normal1);

					float pdf;
					vec3 lightBSDF = BSDF(lightRay.Direction, -LightCacheEntries[lightCacheSampleIndex].IncidentDirection,
										  lightSampleMaterialIndex, lightSampleMaterialTexData, lightSampleHitNormal, pdf);


					float cosLight = saturate(-dot(lightRay.Direction, lightSampleHitNormal));

					// I_in = Flux/2PI (= total outgoing light energy) is known.
					// Want to know the Intensity for a given direction I_out				

					// BSDF = L_out/E_in
					// E_in = I_in / dAreaIn
					// L_out = I_out / (dAreaEmitt * cos(OutgoingDir, Normal) * dSolidAngle)
					// dAreaIn = dAreaEmitt
					//
					// => BSDF = I_out / (I_in * cos(OutgoingDir, Normal) * dSolidAngle)
					//
					// Infitesimal angle -> derivation is 1: dSolidAngle = 1
					//
					// => I_out = I_in * BSDF * cos(OutgoingDir, Normal)

					lightSampleIntensity *= lightBSDF * cosLight;

					#ifdef RUSSIAN_ROULETTE
						// path termination propability: bsdf * dot(N, outDir) / pdf
						// -> bsdf * dot(N, outDir) = "lightSampleIntensity"
						//pdf += DIVISOR_EPSILON;
						//float continuationPropability = GetLuminance(lightBSDF) * cosLight / pdf;
						//connectionLightPathToEyePath = MIS(pdf / continuationPropability);

						connectionLightPathToEyePath = MIS(GetLuminance(lightBSDF) * cosLight);
					#else
						connectionLightPathToEyePath = MIS(pdf);
					#endif
				}

				float cosCamera = abs(dot(lightRay.Direction, hitNormal));

				float pdf;
				vec3 bsdf = BSDF(ray.Direction, lightRay.Direction, triangle.w, materialTexData, hitNormal, pdf); // Note that this is also 1/samplingProbability!

			#ifdef RUSSIAN_ROULETTE
				// path termination propability: bsdf * dot(N, outDir) / pdf
				// connection propability: termination * pdf
				// -> bsdf * dot(N, outDir)
				//pdf += DIVISOR_EPSILON;
				//float continuationPropability = GetLuminance(bsdf) * cosCamera / pdf;
				//float connectionEyePathToLightPath = MIS(pdf / continuationPropability);

				float connectionEyePathToLightPath = MIS(GetLuminance(bsdf) * cosCamera);
			#else
				float connectionEyePathToLightPath = MIS(pdf);
			#endif

				float light_pathProbability = LightCacheEntries[lightCacheSampleIndex].PathProbability;
				float light_anyPathProbabilitySum = LightCacheEntries[lightCacheSampleIndex].AnyPathProbabilitySum;

				float connectedPathPropability = light_pathProbability * pathProbability;
				float mis = connectedPathPropability / 
							(light_pathProbability * connectionEyePathToLightPath * anyPathProbabilitySum + 
							 pathProbability * connectionLightPathToEyePath * light_anyPathProbabilitySum + connectedPathPropability);

				vec3 irradiance = (lightSampleWeight * mis * 
								   cosCamera / lightDistSq) * lightSampleIntensity;
				color += irradiance * pathThroughput * bsdf; 
			}
		}

		float samplePDF;
		ray.Direction = SampleBSDF(ray.Direction, triangle.w, materialTexData, randomSeed, hitNormal, pathThroughput, samplePDF);
		ray.Origin += ray.Direction * RAY_HIT_EPSILON;
	#ifdef RUSSIAN_ROULETTE
		float continuationPropability = GetLuminance(pathThroughput);
		if(Random(randomSeed) >= continuationPropability) // if continuationPropability is zero, path should be stoped -> >=
			break;
		pathThroughput /= continuationPropability; // Only change in spectrum, no energy loss.
		samplePDF *= continuationPropability;
	#endif

		// The probability to sample a vertex is the pdf times 1-terminationProbability
		samplePDF = MIS(samplePDF);
		anyPathProbabilitySum = anyPathProbabilitySum * samplePDF + pathProbability;
		pathProbability *= samplePDF;
	}

	vec4 final = vec4(color, 1.0);
	final += imageLoad(OutputTexture, gridPosition);
	imageStore(OutputTexture, gridPosition, final);
}